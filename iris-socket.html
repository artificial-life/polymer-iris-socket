<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iris-polymer-importer/iris-importer.html">
<link rel="import" href="../iris-polymer-stat-display/iris-stat-grabber.html">

<dom-module id="iris-socket">
  <template>
    <iris-stat-grabber id="statGrabber"></iris-stat-grabber>
  </template>

  <script>
    (function() {
      'use strict'
      let request_timeout = 15000;
      let statGrabber = false;

      function request(uri, id, timeout) {
        let resolve;
        let reject;
        let start = Date.now();

        let promise = (new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        })).timeout(timeout || request_timeout, 'operation timeout')

        return {
          promise: promise,
          resolve: function(d) {
            if (statGrabber) statGrabber.storeNetworkStat(uri, start);
            resolve(d);
          },
          reject: reject
        }
      }

      function SocketConnectionMethod(server, port) {
        if (server.indexOf('http') !== 0) server = 'http://' + server;

        let awaits = [];
        let rid = 0;
        let socket = false;
        let auth_token = false;
        let auth_resolve;
        let auth_reject;
        let ready;
        let beats_left = 0;
        let interval_id = false;

        let dc_callback = (r) => console.log('disconnected:', r);
        let restore_callback = (r) => console.log('restored:', r);

        return {
          name: "socket",
          startHeartbeatCounter: function() {
            this.stopHeartbeatCounter();

            interval_id = setInterval(() => {
              beats_left += 1;

              if (beats_left > 5) {
                beats_left = 0;
                console.log('<Socket> no heartbeat, reconnecting');
                if (socket.connected) socket.disconnect();
                socket.connect();
              }
            }, 12000);
          },
          stopHeartbeatCounter() {
            interval_id && clearInterval(interval_id);
          },
          lazyInit: function() {
            if (socket) return socket.connect();

            socket = io.connect(server + ':' + port);
            socket.io.timeout(10000);

            socket.on('connect', () => {
              socket.emit('message', {
                uri: '/auth',
                token: auth_token
              });
            });

            socket.on('disconnect', dc_callback.bind(this));

            socket.on('heartbeat', (d) => {
              beats_left = beats_left > 0 ? beats_left - 1 : 0;
            });

            socket.on('auth-accepted', (result) => {
              //@TODO: check result state and reason
              auth_resolve(true);
              restore_callback();
              this.resubscribe().then((r) => console.log('<Socket> subs restored ', r.length));
              this.startHeartbeatCounter();
            });

            socket.on('message', (data) => {
              if (!data || !data.request_id || !awaits[data.request_id]) return false;

              let rid = data.request_id;
              let request = awaits[rid];

              if (!request.promise.isPending()) return false;

              return data.state ? request.resolve(data.value) : request.reject(data.reason);
            });
          },
          resubscribe() {
            console.log('<Socket> restore subscriptions');
            return Promise.all(_.map(this.subscriptions, (v, uri) => this.request('/subscribe', {
              event: uri
            })));
          },
          storeSubscribtion(uri) {
            //@NOTE: use MAP here
            this.subscriptions = this.subscriptions || {};
            this.subscriptions[uri] = true;
            console.log('<Socket> subscription stored:', this.subscriptions);
          },
          removeSubscribtion(uri) {
            if (!this.subscriptions) return;
            delete this.subscriptions[uri];
            console.log('<Socket> subscription removed:', this.subscriptions);
          },
          close: function() {
            socket.disconnect();
            _.forEach(this.subscriptions, (sub, name) => socket.off(name));
            this.subscriptions = {};
            this.stopHeartbeatCounter();
          },
          onDisconnect(cb) {
            dc_callback = cb;
          },
          onRestore(cb) {
            restore_callback = cb;
          },
          auth: function(token) {
            auth_token = token;

            ready = new Promise(function(res, rej) {
              auth_resolve = res;
              auth_reject = rej;
            }).timeout(request_timeout, 'operation timeout');

            ready.catch((e) => {
              console.log('<Socket> connection closed');
              this.close();
            });

            this.lazyInit();

            return ready;
          },
          request: function(uri, data, timeout) {
            return ready.then(() => {
              data = _.cloneDeep(data) || {};
              rid = (rid + 1) % 10000;
              console.log('<Socket> request#%s url:', rid, uri, data);
              data.request_id = rid;

              socket.emit('message', {
                uri: uri,
                data: data,
                request_id: rid
              });

              awaits[rid] = new request(uri, rid, timeout);

              return awaits[rid].promise;
            });
          },
          subscribe: function(uri, callback) {
            console.log('SUB', uri);
            return this.request('/subscribe', {
              event: uri
            }).then((data) => {
              console.log('<Socket> subscribed on', uri);
              this.storeSubscribtion(uri);
              socket.on(uri, callback);
              return true;
            });
          },
          unsubscribe: function(uri, callback) {
            return this.request('/unsubscribe', {
              event: uri
            }).then((data) => {
              this.removeSubscribtion(uri);
              socket.off(uri, callback);
              return true;
            });
          }
        };
      }


      Polymer({
        is: 'iris-socket',
        attached() {
          this.style.display = 'none';
        },
        getMethod(server, port) {
          //@NOTE: test only
          statGrabber = this.$.statGrabber;
          if (this.method) return this.method;
          this.method = new SocketConnectionMethod(server, port)
          return this.method;
        }
      });
    })();
  </script>

</dom-module>
